# Opal Vanguard: Modular FHSS Messaging System
## Full System Architectural Flow & Technical Specification

This document provides a deep-dive into the "Opal Vanguard" frameworkâ€”a high-fidelity GNU Radio implementation of a Frequency Hopping Spread Spectrum (FHSS) messaging system.

---

## 1. System Overview
Opal Vanguard is designed to provide robust, asynchronous messaging in the 900MHz ISM band. It utilizes **GFSK modulation** combined with **Reed-Solomon FEC** and **Fibonacci LFSR hopping** to maintain link integrity in high-interference environments.

### Core Technical Specs:
*   **Sample Rate:** 10 MHz (Simulation) / 2 MHz (Hardware Target)
*   **Modulation:** GFSK (Modulation Index $h=1.0$, $BT=0.35$)
*   **Channels:** 50 Channels, 150 kHz spacing
*   **Hopping:** Fibonacci LFSR (16-bit), 200ms dwell time
*   **FEC:** Reed-Solomon (15, 11) over GF(16)
*   **Whitening:** $x^7 + x^4 + 1$ LFSR

---

## 2. The Transmitter (TX) Path
The lifecycle of a message begins as a UTF-8 string and ends as a wideband hopped signal.

### Step A: Session & Buffering (`session_manager.py`)
1.  **Input:** A raw PDU (Protocol Data Unit) is received via the `data_in` port.
2.  **Handshake Check:** If the session state is `IDLE`, the manager buffers the message and initiates a **SYN** packet.
3.  **SYN Generation:** A 2-byte packet containing the local **LFSR Seed** is generated to synchronize the receiver's hopping sequence.

### Step B: Packetization (`packetizer.py`)
The Packetizer transforms the raw payload into a structured frame:
1.  **CRC16-CCITT:** Calculates a 2-byte checksum over the (Type + Length + Payload).
2.  **Reed-Solomon FEC:** 
    *   Splits the data into 11-byte chunks (22 nibbles).
    *   Encodes each into two 15-nibble RS blocks.
    *   Result: 11 bytes of data expand to 15 bytes of protected symbols.
3.  **Whitening:** Data is XORed with a bitstream from an $x^7+x^4+1$ LFSR to ensure high transition density (DC balance).
4.  **Framing:**
    *   **Preamble (8 bytes):** `0xAAAA...` for demodulator clock recovery.
    *   **Syncword (4 bytes):** `0x3D4C5B6A` for frame alignment.
    *   **Data Part:** Type + Length + Protected Payload + CRC.
    *   **Tail (32 bytes):** `0x00...` to flush the GFSK demodulator's internal FIR filters.

### Step C: Modulation & Hopping (`top_block_gui.py`)
1.  **GFSK Mod:** Converts the bitstream into complex baseband samples.
2.  **Frequency Rotation:** 
    *   The **Hop Controller** generates a center frequency $f_{hop}$.
    *   The **Rotator** block performs a complex multiplication: $e^{j 2 \pi (f_{hop} - f_{center}) t / f_s}$.
    *   This "hops" the signal to the target channel within the 10MHz bandwidth.

---

## 3. The Channel Model (Simulation)
The "Air" is simulated using the `channels.channel_model` block:
*   **AWGN:** Adds Additive White Gaussian Noise (Stress tested up to ~0.15V).
*   **Frequency Offset:** Simulates local oscillator (LO) mismatch between radios.
*   **Timing Offset ($\epsilon$):** Simulates sample-rate mismatch (Clock drift).

---

## 4. The Receiver (RX) Path
The receiver must "de-hop" and "de-structure" the signal in reverse.

### Step A: De-Hopping
1.  **Inverse Rotation:** The RX Rotator applies the negative phase increment generated by the synchronized LFSR. 
2.  **Baseband Recovery:** This pulls the hopped signal back to $0$ Hz (Baseband) for demodulation.

### Step B: Bit Recovery (`depacketizer.py`)
1.  **GFSK Demod:** Uses a quadrature rate-of-change detector and an M&M clock recovery loop to extract bits.
2.  **Syncword Correlation:** A 32-bit sliding window looks for `0x3D4C5B6A` (or its inverse).
3.  **Header Parsing:** Once found, it de-whitens the next 2 bytes to determine the packet **Type** and **Length**.

### Step C: Error Correction & Validation
1.  **FEC Repair:** 
    *   The 15-byte FEC blocks are converted back to nibbles.
    *   The RS Decoder uses a brute-force validator to find and repair up to 2 nibble errors per block.
2.  **CRC Verification:** The final 2-byte CRC is checked against the repaired data.
3.  **Output:** If the CRC passes, the PDU is sent to the **Session Manager**.

---

## 5. Session Logic (The Handshake)
Synchronization is maintained through a state machine:
1.  **SYN Received:** Node B extracts the 2-byte seed, updates its local **Hop Controller**, and sends an **ACK**.
2.  **ACK Received:** Node A transitions to `CONNECTED` and flushes its message buffer.
3.  **Data Flow:** Both nodes now hop in perfect unison, allowing continuous message exchange.

---

## 6. GUI & Threading Architecture
To prevent high-speed signal processing from locking up the UI, the system uses a **Decoupled Signal Architecture**:
*   **Processing Thread:** GNU Radio blocks handle the bitstream and RF logic.
*   **GUI Thread:** PyQt5 handles the waterfall, sliders, and text box.
*   **Bridge:** `pyqtSignals` are used to thread-safely "emit" events (like `on_data_received`) from the processing thread to the GUI.

---

## 7. Analysis Tools
*   **Inspectrum:** Used to verify the physical layer. By capturing `.cf32` files, we can manually count the bits in the Preamble/Syncword to verify timing and modulation index.
*   **Terminal Logs:** Provide real-time feedback on CRC status and FEC repairs.
